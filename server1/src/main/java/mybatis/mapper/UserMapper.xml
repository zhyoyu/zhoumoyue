<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace命名空间，作用就是对sql进行分类化管理 -->
<mapper namespace="mybatis.mapper.UserMapper">

    <!-- 开启本mapper的namespace下的二级缓存
    type:指定cache接口的实现类的类型，mybatis默认使用PerpetualCache
    要和ehcache整合，需要配置type为ehcache实现cache接口的类型
     -->
    <cache type=""/>
    <!-- 定义resultMap
    将select id id_,username username_ from user 和User类的属性作一个映射关系
    type:resultMap最终映射的java对象类型,可以使用别名
    id:对resultMap的唯一标识
     -->
    <resultMap type="user" id="userResultMap">
        <!-- id表示查询结果集中唯一标识
        column:查询出来的列名
        property:type指定的pojo类型中的属性名
        result:对普通名映射定义
        最终resultMap对column和property作一个映射关系（对应关系）
        -->
        <id column="id_" property="id"/>
        <result column="username_" property="userName"/>
    </resultMap>
    
    <resultMap id="OrdersUserResultMap" type="po.Orders">
        <!-- 配置映射的订单信息 -->
        <!-- id:指定查询列中的唯一标识，订单信息中的唯一标识，如果有多个列组成唯一标识，配置多个id
            column:订单信息的唯一标识列
            property:订单信息的唯一标识 列所映射到Orders中哪个属性
            -->
        <id column="id" property="id"/>
        <result column="user_id" property="userId"/>
        <result column="number" property="number"/>
        <result column="createtime" property="createtime"/>
        <result column="note" property="note"/>

        <!-- 配置映射关联的用户信息 -->
        <!-- association:用于映射关联查询单个对象的信息
        property:要将关联查询的用户信息映射到Orders中哪个属性
        -->
        <association property="user" javaType="po.User">
            <!-- id:关联查询用户的唯一标识
                column:指定唯一标识用户信息的列
                javaType:映射到user的哪个属性
                -->
            <id column="user_id" property="id"/>
            <result column="username" property="username"/>
            <result column="sex" property="sex"/>
            <result column="address" property="address"/>
        </association>
    </resultMap>

    <!-- 在映射文件中配置很多sql语句 -->
    <!-- 通过select执行数据库查询, id:标识映射文件中的sql，
    将sql语句封装到mappedStatement对象中，所以将id称为statement的id
    parameterType: 指定输入参数的类型，这里指定int型
    #{}表示一个占位符
    #{id}:其中的id表示接收输入的参数，参数名称就是id，如果输入参数是简单类型，#{}中的参数名可以任意
    resultType:指定sql输出结果所映射的java对象类型，select指定resultType表示将单条记录映射成java对象
     -->
    <select id="findUserById" parameterType="int" resultType="po.User" useCache="false">
        SELECT * FROM USER WHERE id=#{id}
    </select>

    <!-- 根据用户名称模糊查询用户信息，可能返回多条
    resultType:指定就是单条记录所映射的java对象类型
    ${}:表示拼接sql串，将接收到的参数的内容不加任何修饰拼接在sql中
    使用${}拼接sql，引起sql注入
    ${value}:接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value
    -->
    <select id="findUserByName" parameterType="java.lang.String" resultType="po.User">
        select * from user where username like '%${value}%'
    </select>

    <select id="findUserList" parameterType="po.UserQueryVo" resultType="po.UserCustom">
        select * from user
        <where>
            <!-- 引用sql片段的id，如果refid指定id不在本mapper文件中，需要在前边加namespace -->
            <include refid="query_user_where"/>
            <!-- 在这里还要引用其他的sql片段 -->
        </where>
    </select>

    <!-- 用户信息综合总数 -->
    <select id="findUserCount" parameterType="int" resultType="java.lang.Integer">
        select count(*) from user
        <where>
            <include refid="query_user_where"/>
        </where>
    </select>

    <!-- 使用resultMap进行输出映射
    resultMap:指定定义的resultMap的id,如果这个resultMap在其他的mapper文件，前边需要加namespace
    -->
    <select id="findUserByIdResultMap" parameterType="int" resultMap="userResultMap">
        select id id_, username username_ from user where id=#{value}
    </select>

    <!-- 添加用户
    parameterType:指定输入参数类型是pojo（包括 用户信息）
    #{}中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值
    -->
    <insert id="insertUser" parameterType="po.User">
        <!--
        将插入数据的主键返回，返回到user对象中

        SELECT LAST_INSERT_ID()：得到刚insert进去的主键值，只适用于自增主键
        keyProperty:将查询到主键值设置到parameterType指定的对象的哪个属性
        order:SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序
        -->
        <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
            SELECT LAST_INSERT_ID()
        </selectKey>
        <!--
        使用mysql的uuid()生成主键
        执行过程：
        首先通过uuid（）得到主键，将主键设置到user对象的id属性
        其次在insert执行时，从user对象中取出id属性值
        -->
        <!--<selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String">-->
        <!--SELECT uuid()-->
        <!--</selectKey>-->
        insert into user(username, birthday, sex, address) value(#{userName},#{birthday},#{sex},#{address})
    </insert>

    <!-- 删除用户
    根据id删除用户，需要输入id值
     -->
    <delete id="deleteUser" parameterType="java.lang.Integer">
        delete from user where id=#{id}
    </delete>

    <!-- 更新用户
    需要传入用户id
    需要传入用户的更新信息
    #{id}：从输入user对象中获取id属性值
    -->
    <update id="updateUser" parameterType="po.User">
        update user set username=#{userName},birthday=#{birthday}, sex=#{sex},address=#{address} where id=#{id}
    </update>

    <!-- 定义sql片段
    id:sql片段的唯一标识
    -->
    <sql id="query_user_where">
        <if test="userCustom!=null">
            <if test="userCustom.username!=null and userCustom.username!=''">
                and username like '%${userCustom.userName}%'
            </if>
            <if test="ids!=null">
                <!-- 使用foreach遍历传入ids
                collection:指定输入对象中结合属性
                open:开始遍历时拼接串
                close:结束遍历时拼接的串
                separator:遍历的两个对象中需要拼接的串
                -->
                <!-- 使用实现下边的sql拼接
                AND (id=1 or id=2 or id=3)
                -->
                <foreach collection="ids" item="user_id" open="AND (" close=")" separator="or">
                    <!--- 每个遍历需要拼接的串 -->
                    id=#{user_id}
                </foreach>
            </if>
        </if>
    </sql>

    <select id="findOrdersUserResultMap" resultMap="OrdersUserResultMap">
        select
        orders.*,
        user.username,
        user.sex,
        user.address
        from
        orders,
        user
        where orders,user_id = user.id
    </select>

    <resultMap id="OrdersAndOrderDetailResultMap" type="po.Orders" extends="OrdersUserResultMap">
        <!-- 订单明细
        一个订单关联查询出了多条明细,要使用collection进行映射
        collection:对关联查询到多条记录映射到集合对象中
        property:将关联查询到多条记录映射到po.Orders哪个属性
        ofType:指定映射到list集合属性中pojo的类型
        -->
        <collection property="orderdetails" ofType="po.OrderDetail">
            <!-- id:订单明细唯一标识
            property:要将订单明细的唯一标识映射到Orderdetail的哪个属性
            -->
            <id column="orderdetail_id" property="id"/>
            <result column="items_id" property="itemsId"/>
            <result column="items_num " property="itemsNum"/>
            <result column="orders_id" property="ordersId"/>
        </collection>

    </resultMap>

    <!-- 查询用户及购买的商品 -->
    <resultMap id="UserAndItemsResultMap" type="po.User">
        <!-- 用户信息 -->
        <id column="user_id" property="id"/>
        <result column="username" property="username"/>
        <result column="sex" property="sex"/>
        <result column="address" property="address"/>
        <!-- 订单信息
        一个用户对应多个订单，使用collection映射
        -->
        <collection property="ordersList" ofType="po.Orders">
            <id column="id" property="id"/>
            <result column="user_id" property="userId"/>
            <result column="number" property="number"/>
            <result column="createtime" property="createtime"/>
            <result column="note" property="note"/>
            <!-- 订单明细
        一个订单包括多个明细
        -->
            <collection property="oderDetailList" ofType="po.OrderDetail">
                <id column="orderdetail_id" property="id"/>
                <result column="items_id" property="itemsId"/>
                <result column="items_num" property="itemsNum"/>
                <result column="orders_id" property="ordersId"/>

                <!-- 商品信息
                一个订单明细对应一个商品
                -->
                <association property="items" javaType="po.Items">
                    <id column="items_id" property="id"/>
                    <result column="item_name" property="name"/>
                    <result column="item_detail" property="detail"/>
                    <result column="item_price" property="price"/>
                </association>
            </collection>
        </collection>
    </resultMap>

    <!-- 延迟加载的resultMap -->
    <resultMap id="OrdersUserLazyLoadingResultMap" type="po.Orders">
        <!-- 对订单信息进行映射配置 -->
        <id column="id" property="id"/>
        <result column="user_id" property="userId"/>
        <result column="number" property="number"/>
        <result column="createtime" property="createtime"/>
        <result column="note" property="note"/>
        <!-- 实现对用户的信息进行延迟加载
        select:指定延迟加载需要执行的statement的id(是根据user_id查询用户信息的statement)
        column:订单信息中关联用户信息查询的列，是user_id
        关联查询的sql:
        select orders.*,
        (select username from user where orders.user_id = user.id)username,
        (select sex from user where orders.user_id = user.id）sex
        from orders
        -->
        <association property="user" javaType="po.User" select="findUserById" column="user_id">
            <id column="user_id" property="id"/>
            <result column="username" property="username"/>
            <result column="sex" property="sex"/>
            <result column="address" property="address"/>
        </association>
    </resultMap>
</mapper>